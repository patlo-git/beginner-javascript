<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>
    ARRAY METHODS!!
  </title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <script>
    const toppings = ['Mushrooms ', 'Tomatoes', 'Eggs', 'Chili', 'Lettuce', 'Avocado', 'Chiles', 'Bacon', 'Pickles', 'Onions', 'Cheese'];


    const buns = ['egg', 'wonder', 'brioche'];

    const meats = {
      beyond: 10,
      beef: 5,
      pork: 7
    };

    const prices = {
      hotDog: 453,
      burger: 765,
      sausage: 634,
      corn: 234,
    };

    const orderTotals = [342, 1002, 523, 34, 634, 854, 1644, 2222];

    const feedback = [
      { comment: 'Love the burgs', rating: 4 },
      { comment: 'Horrible Service', rating: 2 },
      { comment: 'Smoothies are great, liked the burger too', rating: 5 },
      { comment: 'Ambiance needs work', rating: 3 },
      { comment: 'I DONT LIKE BURGERS', rating: 1 },
    ];


    /*
      Static Methods
    */

    // Array.of(); used for creating an array from its argument
    // [...'wes']
    // // expected output 
    // ['w','e','s']

    // Make a function that creates a range from x to y with Array.from(); very handy
    // can denote in function, _item, to say it doesn't do anything
    // function createRange(start, end) {
    //   const range = Array.from( { length: end - start + 1}, function(_item, index) {
    //     return index + start ;
    //   });
    //   return range;
    // }

    // const myRange = createRange(3, 7);
    
    // // Check if the last array you created is really an array with Array.isArray();
    // console.log(Array.isArray(myRange));

    // // Take the meats object and make three arrays with Object.entries(), Object.keys, Object.values()

    // console.log(Object.entries(meats));
    // console.log(Object.keys(meats));
    // console.log(Object.values(meats));

    // // Object.entries(meats).forEach(entry => {
    // //   // const key = entry[0];
    // //   // const value = entry[1];

    // //   // OPTION: COULD ALSO DO
    // //   // takes first item of entry array, 
    // //   // puts in variable called key,
    // //   // takes second item of entry array,
    // //   // puts it in a second variable called value.
    // //   // DESTRUCTURING
    // //   const [key, value] = entry;
    // //   console.log(key, value);
    // // });

    // // could go one step further and ALSO do
    // Object.entries(meats).forEach(([key, value]) => {
    //   console.log(key, value);
    // });

    // /*
    //   Instance Methods
    // */
    // //  Methods that live on each array

    // // Display all bun types with " or " - use join()
    // console.log(buns.join(' or '));


    // // We have a string "hot dogs,hamburgers,sausages,corn" - use split() to turn it into an array
    // const foodString = "hot dogs,hamburgers,sausages,corn";
    // console.log(foodString.split(','));

    // // take the last item off toppings with pop()
    // const lastItem = toppings.pop();
    // console.log(lastItem);
    // // add it back with push()
    // toppings.push(lastItem);
    // console.log(toppings);
    
    // // take the first item off toppings with shift()
    // const firstItem = toppings.shift();
    // console.log(firstItem);
    // // add it back in with unshift()
    // toppings.unshift(firstItem);

    // // Do the last four examples, but immutable (with spreads and new variables)
    // // TAKING THE LAST ITEM OFF, and adding it back on, WITHOUT USING POP
    // // let newToppings = toppings.slice(0, toppings.length - 1);
    // // console.log(newToppings, 'new length');
    // // newToppings = [...newToppings, toppings[toppings.length - 1]];
    // // console.log(newToppings, 'original length');
    
    // // TAKING THE FIRST ITEM OFF, and adding it back on, WITHOUT USING SHIFT
    // let newToppings = toppings.slice(1, toppings.length);
    // console.log(newToppings, 'new length');
    // newToppings = [toppings[toppings.length - 9], ...newToppings];
    // console.log(newToppings, 'original length');

    // // Make a copy of the toppings array with slice()
    // const toppingsCopy = toppings.slice(0);
    // toppings[0] = 'Mushy boy';
    // console.log(toppings, 'toppings OG');
    // console.log(toppingsCopy, 'toppings copy');

    // // Make a copy of the toppings array with a spread
    // const toppingsCopy2 = [...toppings];
    // console.log(toppingsCopy2);

    // // take out items 3 to 5 of your new toppings array with splice()
    // toppingsCopy.splice(3,5);
    // console.log(toppingsCopy);

    // // find the index of Avocado with indexOf() / lastIndexOf()
    // // works with any types
    // const avoIndex = toppings.indexOf('Avocado');
    // console.log(avoIndex);

    // const avoIndexLast = toppings.lastIndexOf('Avocado');
    // console.log(avoIndexLast);

    // // Check if hot sauce is in the toppings with includes()
    // // includes is not case sensitive
    // const hotSauceCheck = toppings.includes('Hot Sauce');
    // console.log(hotSauceCheck);
    // // add it if it's not
    // if(!hotSauceCheck) {
    //   toppings.push('Hot Sauce');
    // }
    // console.log(toppings);
    // // flip those toppings around with reverse()
    // // reverse is mutable
    // toppings.reverse();
    // console.log(toppings, 'toppings reversed - mutable');
    
    // // take a copy with our Spread operator and then call reverse() on that
    // const toppingsReversed = [...toppings].reverse();
    // console.log(toppingsReversed, 'toppings reversed -  inmutable');

    /*
      Callback Methods
    */

    // find the first rating that talks about a burger with find()
    // findBurgRating(element, index, array)
    // function findBurgRating(singleFeedback) {
    //   return singleFeedback.comment.includes('burg')
    //   // as soon as you pass true to the function, using include, it thinks you've found what you're looking for, returns it, and stops
    // }

    // same thing
    // const findBurgRating = function (singleFeedback) {
    //   return singleFeedback.comment.includes('burg')
    // }

    // same thing
    // const findBurgRating = (singleFeedback) => {
    //   return singleFeedback.comment.includes('burg')
    // }

    // same thing
    // const findBurgRating = (singleFeedback) => { singleFeedback.comment.includes('burg') }
    
    // same thing, but grouping in an object, put the function inside the object, making it a method
    // const util = {
    //   findBurgRating: function (singleFeedback) {
    //   return singleFeedback.comment.includes('burg')
    //   }
    // }

    // // then when we're looking for something we just put util.findBurg
    // const burgRating = feedback.find(util.findBurgRating);
    // console.log(burgRating);

    // no parenthesis on the end of findBurgRating, b/c we're not calling it, just passing reference to the function, and JS is going to run the func once for each of the feedbacks in our feedback array
    // the arg of find is going to be a function that either returns t or f when it finds an item it wants.
    // const burgRating = feedback.find(findBurgRating);
    // console.log(burgRating);

    // create a function that creates a function for us
    // function that makes another function
    // mama function that returns another function
    // **********************************************
    function findByWord(word) {
      return function (singleFeedback) {
        return singleFeedback.comment.includes(word);
      }
    }

    const burgFinder = findByWord('burg');
    const burgRating = feedback.find(burgFinder);

    // for a smoothie finder but in a different format
    // findByWord('Smoothie') doesn't find the smoothie itself,
    // it just returns a function which then, in turn, will find it for you.
    const smoothieRating = feedback.find(findByWord('Smoothie'));

    console.log(burgRating);
    console.log(smoothieRating);
    
    // find all ratings that are above 2 with filter()
    // like find() but returns an new array instead of just one item
    // loops over everyone and returns either true or false
    // minRating = value?
    function filterByMinRating(minRating) {
      // don't have to name this function, but you could
      return function(singleFeedback) {
        return singleFeedback.rating > minRating
      }
    }
    // if singleFeedback rating is greater than 2 return true else false
    const goodReviews = feedback.filter(filterByMinRating(2));
    // same as above, but passing in the function
    // const goodReviews = feedback.filter(singleFeedback => singleFeedback.rating > 2)
    console.table(goodReviews)
    
    // find all ratings that talk about a burger with filter()
    // returns true if singleFeedback comment includes burg
    const burgRatings = feedback.filter(findByWord('burg'));
    console.table(burgRatings);

    // Remove the one star rating however you like!
    // OPTIONS_could filter ratings in ones in all caps.
    // ratings equal to 1
    const legitRatings = feedback.filter(single => single.rating === 1);
    console.table(legitRatings);


    // check if there is at least 5 of ONE type of meat with some()
    // some() tests whether at least one element in the array passes the test implemented by the provided function.
    // It returns true if, in the array, it finds an element for which the provided function returns true; otherwise it returns false. 
    // It doesn't modify the array.
    // turn the meats object into an array using Object.values, return t or f whether meatValue is >= 5.
    // loops over every single value returned, checks if at least one of the values is >= 5 then return true. (how do we see which one that is?)
    const isThereEnoughOfAtLeastOneMeat = Object.values(meats).some(meatValue => meatValue >= 5)
    console.log(isThereEnoughOfAtLeastOneMeat);

    // make sure we have at least 3 of EVERY meat with every()
    // like some(), but every is everything meets our criteria
    // The every() method tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.
    const isThereEnoughOfEveryMeat = Object.values(meats).every(meatValue => meatValue >= 3)
    console.log(isThereEnoughOfEveryMeat);

    // sort the toppings alphabetically with sort()
    // sorts the elements of an array in place and returns the sorted array. 
    // The default sort order is ascending, built upon converting the elements into strings, 
    // then comparing their sequences of UTF-16 code units values.
    // by default sorts in strings, alphabetically. need to tell it how to sort
    // hence, all this code. for strings it's easier (see toppings.sort())
    // takes a callback function (our favorite) called compareFunction (optional), which specifies a function that defines the sort order. if omitted the array elements are converted to strings then sorted.
    // can use math to return a -1, 0, or 1, to help it determine its sorted order, but can use any neg, 0, or pos number
    // can uncomment this out to see how it works
    const numbers = [1, 2, 100, 3, 200, 400, 155];
    // when console.logging it actually switches puts b before a? for some fucking reason
    // if compareFunction(a, b) returns less than 0, sort a to an index lower than b (i.e. a comes first)
    //  if compareFunction(a, b) returns 0, leave a and b unchanged with respect to each other, but sorted with respect to all different elements. (not all browsers respect this)
    // if compareFunction(a, b) returns greater than 0, sort b to an index lower to a (i.e. b comes first)
    // const numbersSorted = numbers.sort(function (firstItem, secondItem) {
      // console.log(firstItem, secondItem, 'unsorted numbers');
      // if (firstItem > secondItem) {
      //   return 1;
      // } else if (secondItem > firstItem) {
      //   return -1;
      // } else {
      //   return 0;
      // }
      // more concise since they're already numbers
      // return firstItem - secondItem;
    // });

    const numbersSorted = numbers.sort((firstItem, secondItem) => firstItem - secondItem);
    console.log(numbersSorted, 'numbers sorted');
    // console.log(toppings.sort());

    // example from MDN
    const numbersMDN = [4, 2, 1, 3];
    numbersMDN.sort(function(a, b) {
      return a - b;
    });
    console.log(numbersMDN);

    // sort the order totals from most expensive to least with .sort()
    function numberSort (a, b) {
      return a - b;
    }
    console.log(orderTotals.sort(numberSort), 'order totals');
    // **********************************************************
    // Sort the prices with sort()
    // First we convert object into array where each item is an array, with two items a piecce.
    // Then we sort over each of them giving us those first and second items/values of array.
    const productsSortedByPrice = Object.entries(prices).sort(function(a,b) {
      // store in a variable the values of a from second [1] array index, which is the price.
      const aPrice = a[1];
      const bPrice = b[1];
      return aPrice - bPrice;
    });
    // turn this sorted array BACK into an Object. wrap it in an object.fromEntries.
    // why is the Object out of order now? It's not like his object shown, nor is it an exact copy of the array
    // looks like it's putting it alphabetically when put back in object
    console.table(Object.fromEntries(productsSortedByPrice, 'sorted table'));


    /*
      Looping Methods (next)
    */

  </script>
</body>

</html>
